// mkobsd creates custom OpenBSD ISO images for automated installations.
package main

import (
	"context"
	"flag"
	"fmt"
	"io/fs"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"

	"gitlab.com/stephen-fox/mkobsd/internal/mkobsd"
)

const (
	appName = "mkobsd"
	usage   = appName + `

SYNOPSIS
  ` + appName + ` [options] -` + releaseArg + ` <release> -` + cpuArchArg + ` <arch> -` + isoOutputPathArg + ` </path/to/new.iso>

DESCRIPTION
  ` + appName + ` automates the creation of OpenBSD installer ISO images.
  It was designed to create unattended installer images by including an
  auto_install.conf file and/or an install.site script and tar set in the
  ISO file itself. For more information regarding OpenBSD installer
  automation, please refer to the manual pages mentioned in the
  SEE ALSO section for more information

  For examples, please execute ` + appName + ` with the -` + advHelpArg + ` argument.

SEE ALSO
  autoinstall(8), install.site(5)

OPTIONS
`

	advHelpDoc = appName + `

EXAMPLES

  The following example creates an unattended installer image that does not
  contain any hard-coded credentials. It writes the SSH server's public keys
  to the console, thus allowing the sysadmin to copy them out-of-band to
  their own machine.

  The auto_install.conf file automates the OpenBSD installer. The install.site
  script installs several packages, creates a new user with the specified SSH
  public key, and adds the user to /etc/doas.conf.

    $ find . -type f
    ./auto_install.conf
    ./create.sh
    ./generic/etc/adduser.conf
    ./generic/install.site
    ./generic/usr/local/bin/this-ends-up-in-usr-local-bin.sh

    $ cat create.sh
    #!/bin/sh

    set -u

    dir_path="$(realpath $(dirname "${0}"))"

    arch=amd64
    version=7.3

    doas mkobsd \
      -o "${dir_path}/example-${version}-${arch}.iso" \
      -a ${arch} \
      -r ${version} \
      -i "${dir_path}/auto_install.conf" \
      -d "${dir_path}/generic"

    $ cat auto_install.conf
    System hostname = example
    Password for root = *************
    Set name(s) = +site* -game*
    Continue without verification = yes

    $ cat generic/install.site
    #!/bin/sh

    set -ex

    add_admin() {
      local username="${1}"
      shift
      local home="/home/${username}"

      echo "permit nopass ${username} as root" >> /etc/doas.conf

      /usr/sbin/adduser -batch "${username}" wheel

      for ssh_public_key in "${@}"; do
        echo "${ssh_public_key}" >> "${home}/.ssh/authorized_keys"
      done
    }

    /usr/sbin/pkg_add -a vim--no_x11 go git

    echo "@reboot /bin/sh -c '(echo -----BEGIN SSHD PUBLIC KEYS-----; /bin/cat /etc/ssh/*.pub; echo -----END SSHD PUBLIC KEYS-----) > /dev/tty00'" >> /var/cron/tabs/root

    add_admin me 'ecdsa-sha2-nistp256 AAAAAAA buh'

    /usr/bin/doas -C /etc/doas.conf

    /bin/chmod 0600 /etc/doas.conf

    $ cat generic/etc/adduser.conf
    #
    # /etc/adduser.conf - automatic generated by adduser(8)
    #
    # Note: adduser reads *and* writes this file.
    #	You may change values, but don't add new things before the
    #	line ''## DO NOT DELETE THIS LINE!''
    #	Also, unquoted strings may cause warnings
    #

    # verbose = [0-2]
    verbose = 1

    # Get new password for new users
    # defaultpasswd =  yes | no
    defaultpasswd = "no"

    # Default encryption method for user passwords
    # Methods are all those listed in login.conf(5)
    encryptionmethod = "auto"

    # copy dotfiles from this dir ("/etc/skel" or "no")
    dotdir = "/etc/skel"

    # send message to user? ("yes" or "no")
    send_message = "no"

    # send this file to new user ("/etc/adduser.message")
    message_file = "/etc/adduser.message"

    # config file for adduser ("/etc/adduser.conf")
    config = "/etc/adduser.conf"

    # logfile ("/var/log/adduser" or "no")
    logfile = "/var/log/adduser"

    # default HOME directory ("/home")
    home = "/home"

    # List of directories where shells located
    # path = ('/bin', '/usr/bin', '/usr/local/bin')
    path = ('/bin', '/usr/bin', '/usr/local/bin')

    # common shell list, first element has higher priority
    # shellpref = ('bash', 'tcsh', 'ksh', 'csh', 'sh')
    shellpref = ('csh', 'sh', 'bash', 'tcsh', 'ksh', 'nologin')

    # defaultshell if not empty ("bash")
    defaultshell = "sh"

    # defaultgroup ('USER' for same as username or any other valid group)
    defaultgroup = "USER"

    # new users get this uid
    uid_start = 1000
    uid_end = 2147483647

    # default login.conf(5) login class
    defaultclass = "default"

    # login classes available from login.conf(5)
    # login_classes = ('default', 'daemon', 'staff')
    login_classes = ('default', 'daemon', 'staff', 'authpf', 'pbuild', 'bgpd', 'unbound', 'vmd', 'xenodm')

    ## DO NOT DELETE THIS LINE!
    ## your own variables, see /etc/adduser.message

    ## end
`

	helpArg               = "h"
	advHelpArg            = "H"
	commandModeArg        = "c"
	isoOutputPathArg      = "o"
	baseDirPathArg        = "b"
	dirPermArg            = "p"
	releaseArg            = "r"
	cpuArchArg            = "a"
	isoMirrorArg          = "m"
	autoinstallArg        = "i"
	installsiteDirArg     = "d"
	preserveSiteTarIDsArg = "P"
	logTimestampsArg      = "t"
	debugArg              = "D"
	debugVerifyISOArg     = "K"

	debugEnvName = "MKOBSD_DEBUG"

	defaultBaseDirPath = "/home/_" + appName
)

func main() {
	log.SetFlags(0)

	err := mainWithError(os.Args)
	if err != nil {
		log.Fatalln("fatal:", err)
	}
}

func mainWithError(osArgs []string) error {
	flagSet := flag.NewFlagSet(osArgs[0], flag.ExitOnError)

	help := flagSet.Bool(
		helpArg,
		false,
		"Display this information")
	advHelp := flagSet.Bool(
		advHelpArg,
		false,
		"Display advanced usage information and examples")
	isoOutputPath := flagSet.String(
		isoOutputPathArg,
		"",
		"The file path to save the resulting .iso file to")
	baseDirPath := flagSet.String(
		baseDirPathArg,
		defaultBaseDirPath,
		"The base directory for builds")
	baseDirsPerm := filePermFlag{perm: 0755}
	flagSet.Var(
		&baseDirsPerm,
		dirPermArg,
		"The default file mode permission bits for directories\n")
	release := flagSet.String(
		releaseArg,
		"",
		"OpenBSD release version (e.g., '7.2')")
	cpuArch := flagSet.String(
		cpuArchArg,
		"",
		"Target CPU architecture (e.g., 'amd64')")
	isoMirror := flagSet.String(
		isoMirrorArg,
		"https://cdn.openbsd.org/pub/OpenBSD",
		"OpenBSD mirror URL")
	autoinstallFilePath := flagSet.String(
		autoinstallArg,
		"",
		"The path to the autoinstall configuration file (see also:\n"+
			"'man autoinstall')")
	installsiteDirPath := flagSet.String(
		installsiteDirArg,
		"",
		"Optionally specify an install.site directory to be included in the\n"+
			"resulting ISO file. The directory's contents will be placed in a tar\n"+
			"archive and extracted to '/' at install time. If an executable file\n"+
			"named 'install.site' exists at the root of the directory, it will be\n"+
			"executed by the installer (see also: 'man install.site')")
	preserveSiteTarIDs := flagSet.Bool(
		preserveSiteTarIDsArg,
		false,
		"Preserve UID and GIDs of the install.site directory when creating a tar.\n"+
			"Defaults to not preserving UIDs and GIDs (root:wheel is used)")
	logTimestamps := flagSet.Bool(
		logTimestampsArg,
		false,
		"Include timestamps in log messages")
	debug := flagSet.Bool(
		debugArg,
		false,
		"Enable debug mode and step through each stage of the build workflow.\n"+
			"May also be enabled by setting the '"+debugEnvName+"' environment variable\n"+
			"to 'true'")
	debugVerifyISO := flagSet.Bool(
		debugVerifyISOArg,
		false,
		"Do not delete original OpenBSD .iso if verification fails")

	flagSet.Parse(osArgs[1:])

	if *help {
		_, _ = os.Stderr.WriteString(usage)
		flagSet.PrintDefaults()
		os.Exit(1)
	}

	if *advHelp {
		_, _ = os.Stderr.WriteString(advHelpDoc)
		os.Exit(1)
	}

	var err error

	flagSet.VisitAll(func(f *flag.Flag) {
		if err != nil {
			return
		}

		if f.Value.String() == "" && !strings.HasPrefix(f.Usage, "Optional") {
			err = fmt.Errorf("please specify '-%s' - %s",
				f.Name, strings.ReplaceAll(f.Usage, "\n", " "))
		}
	})
	if err != nil {
		return err
	}

	if os.Getenv(debugEnvName) == "true" {
		*debug = true
	}

	if *logTimestamps {
		log.SetFlags(log.Flags() | log.Ldate | log.Ltime)
	}

	owner := os.Getuid()
	if owner != 0 {
		return fmt.Errorf("must be root to execute this program (proc uid is: %d)", owner)
	}

	group := os.Getgid()
	if group != 0 {
		return fmt.Errorf("must be root to exexcute this program (proc gid is: %d)", group)
	}

	cache := &mkobsd.BuildCache{
		BasePath:       *baseDirPath,
		BaseDirsPerm:   baseDirsPerm.perm,
		HTTPClient:     http.DefaultClient,
		DebugISOVerify: *debugVerifyISO,
	}

	ctx, cancelFn := signal.NotifyContext(context.Background(),
		syscall.SIGINT, syscall.SIGTERM)
	defer cancelFn()

	var beforeFn func(string, map[string]string) error
	var afterFn func(string, map[string]string) error

	if *debug {
		beforeFn = func(s string, info map[string]string) error {
			log.Printf("[%s] start - info: %+v - press enter to continue", s, info)
			err := readNewlineCtx(ctx)
			if err != nil {
				return err
			}
			return nil
		}

		afterFn = func(s string, info map[string]string) error {
			log.Printf("[%s] finished - info: %+v - press enter to continue", s, info)
			err := readNewlineCtx(ctx)
			if err != nil {
				return err
			}
			return nil
		}
	} else {
		beforeFn = func(s string, _ map[string]string) error {
			log.Printf("[%s] start", s)
			return nil
		}

		afterFn = func(s string, _ map[string]string) error {
			log.Printf("[%s] finished", s)
			return nil
		}
	}

	err = cache.BuildISO(ctx, &mkobsd.BuildISOConfig{
		ISOOutputPath:       *isoOutputPath,
		Mirror:              *isoMirror,
		Release:             *release,
		Arch:                *cpuArch,
		AutoinstallFilePath: *autoinstallFilePath,
		InstallsiteDirPath:  *installsiteDirPath,
		PreserveSiteTarIDs:  *preserveSiteTarIDs,
		BeforeActionFn:      beforeFn,
		AfterActionFn:       afterFn,
	})
	if err != nil {
		return err
	}

	return nil
}

func readNewlineCtx(ctx context.Context) error {
	newline := make(chan error, 1)

	go func() {
		_, err := fmt.Scanln()
		newline <- err
	}()

	select {
	case <-ctx.Done():
		os.Stdin.Close()

		return ctx.Err()
	case err := <-newline:
		if err != nil {
			return err
		}

		return nil
	}
}

type filePermFlag struct {
	perm fs.FileMode
}

func (o *filePermFlag) Set(v string) error {
	i, err := strconv.ParseUint(v, 8, 32)
	if err != nil {
		return err
	}

	o.perm = fs.FileMode(uint32(i))

	return nil
}

func (o *filePermFlag) String() string {
	return fmt.Sprintf("%o | %s", o.perm, o.perm.String())
}
